MACHINE LEARNING
	Przykładowy problem do rozwiązania
		Problem -> Jest miasto, które nawiedza powódź
		Pytanie -> Przewidują, że bedzie 2400mm opadów w tym roku, jakie będą szkody wyrzadzone przez taki opady

	Problem Solving Process
		- Identify data that is relevant to the problem -> 'Features' are catagories of data pints that affect the value of a "label"
			* If the amount of ANNUAL RAINFALLL(independent variable -> 'feature') changes, we will probably see a change in FOOD DAMAGE COSTS(dependent variable -> 'label')
		- Assemble a set of a data related to the problem you're trying to solve -> Datasets almost always clenup or formatting
			* Data on Past Events:
			Year	Total	Raifnall(mm) Flood Damage(milion $)
			2008	250		2.1
			2009	197		1.2
			2010	274		2.5
			2011	291		5.3
			2012	136		0	
			2013	306		6.2
		- Decide on the type of output you are predicting -> Regression used with continuos values, classification used with discrete values
			* We have two common types of output:
				1) Classification -> The value of our labels belong to a discrete set
					- Jego output to dwie przeciwne rzeczy np:
						true/false
						spam/not spam
						score no score

						Przykłady:
							Na podstawie ilosci spędoznych godzin na nauce, czy student zda egzmain, czy nie?
								output to: zda ub nie zda
							Na podsawie contentu emaila, czy trafi do spamu? 
								output to spam lub nie spam
							Na podstawie pozycji poycji, z ktorej strzela piłkarz, trafi cdo bramki?
								output to: trafi lub nie trafi

						Przy classyfication mamy pewne możłiwości, ale nie mamy np. 5.5$, albo 4.33 kg itd. Mamy wybory, ale nie musimy mieć tlyko dwóch wboró, możemy mieć ich wiele.

				2) Regression -> The value of our labels belong to a continuos set
					- Jego output należy do pewnego konituum wartości, np:
						1) Na podstawie rocznika, modelu i marki samochodu jaka jest jego wartość?
							Odpowiedź będzie coś pomiędzy 0zł a 200 000zł (więc jest regression)
						2) Na podtawie ilosci spożytych kalorii danej osoby i ilośći ćwiczen, ile waży?
							Odpowiedź będzie pomiędzy 20kg a 120kg
						4) Na podstawie wyskości drzewa, jaki jest jego wiek?
							Odpowiedź będzie od 0 do 500 lat

		- Based on type of output, pick an algorithm that will determine a correlation between your 'features' and 'labels' -> Many, many different algorithms exist, each with pros and cons
		- Use model generated by algorithm to make a prediction -< Models relate the value of 'features' to the value of 'labels'

	Przykład z PLINK game
		Goal: Given some data about where a ball is dropped from, can we predict what bucket it will end up in?

		"Relevant data" dla naszego zadania:
			- Pozycja zrzucania piłki
			- Numer kosza, do którego wpada piłka
			- Skala "Odbijalności" piłki
			- Rozmiar piłki

		Więc ostatecznie:
			"Features":
				- Drop position
				- Ball Bounciness
				- Ball Size
			"Labels":
				- Bucket a ball lands in

			Changing one of "features" value will probably change "labels" value

		Assemble a set of a data related to the problem - czyli ustalenie w jaki sposób będziemy przechowywać dane do naszej analizy
			- Będizmey miec tablice z tablicami (Array of arrays approach (dobre podejście, chyba najlepsze))
				w pojedyńćzej talibcy (tej wenątrz głównej tablicy) bedzie:
					[dropPosition, bounciness, ball size, bucket]

		Od tego momentu zacznie się pisanie kodu w projekcie, zeby zbeirać dane w naszej aplikacji

		Następny krok to ocenienie jaki mamy tu typu problem (czyli czy bedzie regression or classyfication)
			Będzie tutaj CLASSYFICATION -> ponieważ, jest tu 10 pudełek do któych wada piłka i tylko to, tylko
			te 10 możliwości, więc nie mamy tutaj pewnego rodzaju przedziału tak jak w przykładach z regression. Mamy tylko pewne dostępne opcje, i tyle, w naszym przypadku 10 opcji. Może to się wydawać dziwne, ale trzeba taką metodę przyjąć. Przy classyfication mamy pewne możłiwości, ale nie mamy np. 5.5$, albo 4.33 kg itd. Mamy wybory, ale nie musimy mieć tlyko dwóch wboró, możemy mieć ich wiele.

			The ball can only land in one of these buckets

		Do naszego przypadku użyjemy poniższego algorytmu
			K-Neares Neighbor (knn) -> jeden z wieu algorytmów
				W kursie był krótki opis i porónanie do ptaków. Jeśli widzisz wiele tych smaych ptaków na niebie i nagle dolatuje do nich kolejny bardzo podobny, to można z dużą dozą prawdopodobieńśtwa założyc, że jest tot en sam ptak.

				Jeśli mamy coś takiego
					Drop position:	Bucket:
					298				4
					300				4
					299				4
					301				4
					300				4
				Teraz stawiajać pytanie, do jakiego pudełka wpadnie piłka z pozycji 300?
				Możemy z dużą dozą prawdopodobieństwa powiedzieć, że do pudłęka nr 4.
				KNN algorytm patrzy na pewne podbne inputy (features), bierze pod uwage ich wynik
				po czym mowi, ze skoro w takich pozycjach spadło do pudełka 4, to przy 4 prawdopodobnie też wpadnie do pudełka 4

				Nasza implementacja KNN (with one independent variable)
					Which bucket will a ball go into dropped at 300px? ->
					-> Drop a ball a bunch of times all around the board, record which bucket it goes into ->
					-> For each observation, substract drop point from 300px, take absolute value abs(dropPosition - 300) ->
					-> Sort the result from least to greatest ( tutaj sortujemy pod względem tej wartości po wcyciągnieciu z niej wartości bezwzględnej czyli z abs(dropPosition - 300). Generanei u góry będą wtedy zrzucenia piłki najbliżej pozycji 300px) ->
					-> Look at the "k" top records. What was the most common bucket? "k" oznacza tutaj top 5 lub 6 lub whatever wynikow. Dla k=3 bierzemy 3 wyniki z góry naszej tabeli, i wybeiramy najczęstszy przypadek, czyli do jakeigo pudełka piłka wpada najczeciej. Oczywiście ilość "k" jest bardzo ważna, ale generlanie "k" moze przyjmować wiele wartości w zależności od Ciebie i co chcesz zrobic ->
					-> Wchichever bucket came up most frequently is the one ours will probably go into

			Po początkowej analizie, w naszym przypadku wyszło, że nie była najlepsza. Trzeba pamiętać, że tak się często zdarza i wtedy trzeba wykonać pewne kroki:

				Our Prediction was bad!:

					- Adjust the parameters of the analysis -> np. zmienić parametr "k"
					- Add more features to explain the analysis -> np. dodać "odbijalność" i rozmiar piłki
					- Change the prediction point -> Może z punktem 300 jest coś dziwnego i warto sprawdzić inne pozycje
					- Accept that maybe there isn't good correlation -> Jeśli ciagle się coś nie zgadza, może trzeba znaleźć lepszą korelację

				UWAGA! Zanim podejmiemy jakiś z powyższych kroków potrzeba coś zrobić
				Doing this is pointless if we don't have a good way to compare accuracy with different settings!

				Teraz przykład ze znalezieniem dobrego "k"
					Finding an ideal K
					-> Revord a bunch of data points
					-> Split that data into a 'traning' set and a 'test' set
						example:
						Traning              	Test
						[40, .5, 16, 1]		    [10, .5, 16, 1]
						[140, .5, 16, 2]		[137, .5, 16, 2]
						[250, .5, 16, 2]		[150, .5, 16, 2]
						[250, .5, 16, 2]		[260, .5, 16, 2]
			
					-> For each 'test' record, run KNN using the 'traning' data
					-> Does the result of KNN equal the 'test' record bucket

					Czyli generalnie weżmiemy pierwszy element z test [10, .5, 16, 1]
					i na podstawie danych z Traning bedziemy chcieli przewidzieć gdzie wpadnie piłka z pozycji "10", bo taka pozycja jest w pierwszym elemencie "Test", jeśli algorytm przewidzi, ze wpadnie 1, to mamy pierwszy mały sukces. Taką samą operację zrobimy dla każdego elementu z "Test"
						

            Teraz weźmiemy pod uwagę, więcej zmeinnych:
            	Nasza implementacja KNN (with multiple independent variable)
                    Which bucket will a ball go into dropped at 300px? ->
                    -> Drop a ball a bunch of times all around the board, record which bucket it goes into ->
                    -> TYLKO OBLICZENIA W TYM PUNKCIE SIĘ ZMIENIĄ! - For each observation, substract drop point from 300px, take absolute value abs(dropPosition - 300, boucness - 0.5) ->
                        Wczesniej obliczanie odległosci moglibyśmy rpzedstawić na jednej osi X (one dimentional distance), a teraz te obliczenia będą odległosciach w ukałdzie współrzednych X Y (multi dimentional distance).
                        Odległość będziemy liczyć z pitagorasa, bo to będzie najmniejsza odległość pomiędzy poszczególnymi punktami

                    -> Sort the result from least to greatest ( tutaj sortujemy pod względem tej wartości po wcyciągnieciu z niej wartości bezwzględnej czyli z abs(dropPosition - 300). Generanei u góry będą wtedy zrzucenia piłki najbliżej pozycji 300px) ->
                    -> Look at the "k" top records. What was the most common bucket? "k" oznacza tutaj top 5 lub 6 lub whatever wynikow. Dla k=3 bierzemy 3 wyniki z góry naszej tabeli, i wybeiramy najczęstszy przypadek, czyli do jakeigo pudełka piłka wpada najczeciej. Oczywiście ilość "k" jest bardzo ważna, ale generlanie "k" moze przyjmować wiele wartości w zależności od Ciebie i co chcesz zrobic ->
                    -> Wchichever bucket came up most frequently is the one ours will probably go into

                Jeśli będziemy chcieli uwzględnić 3 zmienne (dropPosition, bouciness, ball size), to będziemy liczyć odległość w 3D

            UWAGA!
                W kursie na początku celowo źle pokazał Osie. Byz a duży rozstaw pomiędzy 0.5 a 0.55 w bounciness.\
                W rzeczywistości jak liczmy odległośc okazuje sie, ze bouciness ma małę znaczenia, bo daje bardzo mały "dodatek" do odległości

            Trzeba więc Znormalizować lub Standaryzować nasze dane!!!

            WARTO zrobić screeny z tego kursu z tych rysunków itd.

            Normalized Dataset = (FeatureValue - minOfFeatureValues) / (maxOfFeatureValues - minOfFeatureValues)